from boto3.session import Session
from botocore.exceptions import ClientError
from botocore.config import Config

import streamlit as st

import datetime
import json
import random
import time


def invoke_model(modelId, system_prompt, messages):
    """
    Invokes Amazon Bedrock Foundational model.

    Args:
        modelId (str): The ID or name of the foundational model to be invoked.
        system_prompt (str): The prompt or instruction to be provided to the model, setting the context or guiding the model's behavior.
        messages (list): A list of messages or input data to be processed by the model.

    Returns:
        str: The response or output generated by the model.
    """

    response = st.session_state["BEDROCK_RUNTIME_CLIENT"].invoke_model(
        modelId=modelId,
        body=json.dumps(
            {
                "anthropic_version": "bedrock-2023-05-31",
                "max_tokens": 4096,
                "temperature": 0,
                "system": system_prompt,
                "messages": messages,
            }
        ),
    )
    result = json.loads(response.get("body").read())
    response = result.get("content", [])[0]["text"]
    return response


def backoff_mechanism(func, modelId, system_prompt, messages):
    """
    Implements a backoff mechanism to handle throttling exceptions.

    Args:
        func (function): The function to be called with backoff.
        modelId (str): The ID or name of the foundational model to be invoked.
        system_prompt (str): The prompt or instruction to be provided to the model, setting the context or guiding the model's behavior.
        messages (list): A list of messages or input data to be processed by the model.

    Returns:
        str: The response or output generated by the model.
    """
    MAX_RETRIES = 5  # Maximum number of retries
    INITIAL_DELAY = 1  # Initial delay in seconds
    MAX_DELAY = 60  # Maximum delay in second

    delay = INITIAL_DELAY
    retries = 0

    while retries < MAX_RETRIES:
        try:
            return func(modelId=modelId, system_prompt=system_prompt, messages=messages)
        except st.session_state[
            "BEDROCK_RUNTIME_CLIENT"
        ].exceptions.ThrottlingException as e:
            print(f"Retry {retries + 1}/{MAX_RETRIES}: {e}")
            time.sleep(delay + random.uniform(0, 1))  # Add a random jitter
            delay = min(delay * 2, MAX_DELAY)
            retries += 1

    return False


class KnowledgeBase:
    """KnowledgeBase class for invoking an Amazon Bedrock knowledgebase instance.

    This class provides a wrapper for invoking a knowledgebase instance hosted on Amazon Bedrock platform.

    Usage:

    knowledgebase = KnowledgeBase(environmentName=environmentName)

    # Retrieves the metadata from DynamoDB if it exists there, or from the knowledge base if the metadata is not found in DynamoDB.
    metadata_uri = knowledgebase.retrieve_metadata(query, sessionId)

    # Get the latest generated CloudFormation template from DynamoDB.
    response_text = knowledgebase.get_generated_cloudformation(sessionId=agent.get_session_id())

    # Reset the session.
    knowledgebase.new_session()

    The class initializes session state on first run. It reuses the session for subsequent calls for continuity.
    """

    def __init__(self, environmentName):
        self.environmentName = environmentName

        if "AGENT_RUNTIME_CLIENT" not in st.session_state:

            st.session_state["AGENT_RUNTIME_CLIENT"] = Session().client(
                "bedrock-agent-runtime", config=Config(read_timeout=600)
            )

        if "TEMPLATE_TABLE" not in st.session_state:

            st.session_state["TEMPLATE_TABLE"] = (
                Session()
                .resource("dynamodb")
                .Table(f"templatestorage-atc-{environmentName}")
            )

        self.KnowledgeBaseId = (
            Session()
            .client("ssm")
            .get_parameter(
                Name=f"/streamlitapp/{environmentName}/KNOWLEDGEBASEID",
                WithDecryption=False,
            )["Parameter"]["Value"]
        )

    def get_kb_yaml(self, sessionId, version="METADATA"):
        """
        Retrieves the YAML metadata from DynamoDB.

        Args:
            sessionId (str): The ID of the session.
            version (str): The version of the metadata to retrieve.

        Returns:
            dict: The YAML metadata.
        """
        return st.session_state["TEMPLATE_TABLE"].get_item(
            Key={"sessionId": sessionId, "version": version}
        )

    def get_generated_cloudformation(self, sessionId, version="v0", key="template"):
        """
        Retrieves the generated CloudFormation template from DynamoDB.

        Args:
            sessionId (str): The ID of the session.
            version (str): The version of the template to retrieve.

        Returns:
            str: The generated CloudFormation template.
        """
        return st.session_state["TEMPLATE_TABLE"].get_item(
            Key={"sessionId": sessionId, "version": version}
        )["Item"][key]

    def put_generated_cloudformation(self, sessionId, template):
        """
        Stores the generated CloudFormation template in DynamoDB.

        Args:
            sessionId (str): The ID of the session.
            template (str): The generated CloudFormation template.

        Returns:
            bool: True if the template is stored successfully, False otherwise.
        """
        try:
            creationDate = str(
                int(datetime.datetime.now(tz=datetime.timezone.utc).timestamp())
            )
            ttl = str(
                int(
                    (
                        datetime.datetime.now() + datetime.timedelta(seconds=900)
                    ).timestamp()
                )
            )

            response = st.session_state["TEMPLATE_TABLE"].update_item(
                Key={"sessionId": sessionId, "version": "v0"},
                # Atomic counter is used to increment the latest version
                UpdateExpression="SET Latest = if_not_exists(Latest, :defaultval) + :incrval, #creationDate = :creationDate, #template = :template, #ttl = :ttl, #is_valud = :is_valid",
                ExpressionAttributeNames={
                    "#creationDate": "creationDate",
                    "#template": "template",
                    "#ttl": "ttl",
                    "#is_valud": "is_valid",
                },
                ExpressionAttributeValues={
                    ":creationDate": creationDate,
                    ":template": template,
                    ":ttl": ttl,
                    ":defaultval": 0,
                    ":incrval": 1,
                    ":is_valid": None,
                },
                # return the affected attribute after the update
                ReturnValues="UPDATED_NEW",
            )

            # Get the updated version
            latest_version = response["Attributes"]["Latest"]

            # Add the new item with the latest version
            st.session_state["TEMPLATE_TABLE"].put_item(
                Item={
                    "sessionId": sessionId,
                    "version": "v" + str(latest_version),
                    "creationDate": creationDate,
                    "template": template,
                    "ttl": ttl,
                }
            )
        except Exception as ex:
            print(f"Error at put_generated_cloudformation {ex}")
            return False
        else:
            return True

    def retrieve_metadata(self, sessionId, query=None):
        """
        Retrieves the metadata from DynamoDB if it exists there, or from the knowledge base if the metadata is not found in DynamoDB.

        Args:
            sessionId (str): The ID of the session.
            query (str): The query to search for relevant documents.

        Returns:
            dict: The YAML metadata.
        """
        response = self.get_kb_yaml(sessionId=sessionId, version="METADATA")

        if "Item" in response:
            # TODO: "S" in response
            relevant_documents = response["Item"]
            print(f"Found item in dynamodb {sessionId}")
        else:
            print(f"Item with key {sessionId} not found.")
            relevant_documents = self.retrieve_relevant_documents(
                sessionId=sessionId, query=query
            )

        metadata = [v for k, v in relevant_documents.items() if "document" in k]

        return metadata

    def new_session(self):
        """
        Resets the session.
        """
        del st.session_state["TEMPLATE_TABLE"]
